const std = @import("std");
const generator = @import("svd2zig-core/zig-generator.zig");
const MemorySection = @import("mcuzig-type/MemorySection.zig");
const Reader = std.fs.File.Reader;
const Dir = std.fs.Dir;
const Allocator = std.mem.Allocator;

const vector_table =
    \\
    \\// These two are the default empty implementations for exception handlers
    \\export fn blockingHandler() void {
    \\    while (true) {}
    \\}
    \\
    \\export fn nullHandler() void {}
    \\
    \\// This comes from the linker script and represents the initial stack pointer address.
    \\// Not a function, but pretend it is to suppress type error
    \\extern fn _stack() void;
    \\
    \\// These are the exception handlers, which are weakly linked to the default handlers
    \\// in the linker script
    \\extern fn resetHandler() void;
    \\extern fn nmiHandler() void;
    \\extern fn hardFaultHandler() void;
    \\extern fn memoryManagementFaultHandler() void;
    \\extern fn busFaultHandler() void;
    \\extern fn usageFaultHandler() void;
    \\extern fn svCallHandler() void;
    \\extern fn debugMonitorHandler() void;
    \\extern fn pendSVHandler() void;
    \\extern fn sysTickHandler() void;
    \\
    \\// The vector table
    \\export const vector_table linksection(".vectors") = [_]?*const fn () callconv(.C) void{
    \\    _stack,
    \\    resetHandler, // Reset
    \\    nmiHandler, // NMI
    \\    hardFaultHandler, // Hard fault
    \\    memoryManagementFaultHandler, // Memory management fault
    \\    busFaultHandler, // Bus fault
    \\    usageFaultHandler, // Usage fault
    \\    null, // Reserved 1
    \\    null, // Reserved 2
    \\    null, // Reserved 3
    \\    null, // Reserved 4
    \\    svCallHandler, // SVCall
    \\    debugMonitorHandler, // Debug monitor
    \\    null, // Reserved 5
    \\    pendSVHandler, // PendSV
    \\    sysTickHandler, // SysTick
    \\};
    \\
;

const startup =
    \\
    \\const main = @import("main.zig");
    \\
    \\// These symbols come from the linker script
    \\extern const __data_loadaddr__: u32;
    \\extern var __data_start__: u32;
    \\extern const __data_end__: u32;
    \\extern var __bss_start__: u32;
    \\extern const __bss_end__: u32;
    \\
    \\export fn resetHandler() void {
    \\    // Copy data from flash to RAM
    \\    const data_loadaddr = @as([*]const u8, @ptrCast(&__data_loadaddr__));
    \\    const data = @as([*]u8, @ptrCast(&__data_start__));
    \\    const data_size = @intFromPtr(&__data_end__) - @intFromPtr(&__data_start__);
    \\    for (data_loadaddr[0..data_size], 0..) |d, i| data[i] = d;
    \\
    \\    // Clear the bss
    \\    const bss = @as([*]u8, @ptrCast(&__bss_start__));
    \\    const bss_size = @intFromPtr(&__bss_end__) - @intFromPtr(&__bss_start__);
    \\    for (bss[0..bss_size]) |*b| b.* = 0;
    \\
    \\    // Call contained in main.zig
    \\    main.main();
    \\
    \\    unreachable;
    \\}
    \\
;

const main =
    \\
    \\const regs = @import("registers.zig");
    \\
    \\pub fn main() void {
    \\    systemInit();
    \\    while (true) {}
    \\}
    \\
    \\fn systemInit() void {}
    \\
;

const ld_part1 =
    \\
    \\/*
    \\******************************************************************************
    \\**
    \\** @file        : l.ld
    \\**
    \\** @author      : Auto-generated by lds-maker
    \\**
    \\** @brief       : Set heap size, stack size and stack location according
    \\**                to application requirements.
    \\**
    \\**                Set memory bank area and size if external memory is used
    \\**
    \\**  Distribution: The file is distributed as is, without any warranty
    \\**                of any kind.
    \\**
    \\******************************************************************************
    \\** @attention
    \\**
    \\** Copyright (c) 2023 STMicroelectronics.
    \\** All rights reserved.
    \\**
    \\** This software is licensed under terms that can be found in the LICENSE file
    \\** in the root directory of this software component.
    \\** If no LICENSE file comes with this software, it is provided AS-IS.
    \\**
    \\******************************************************************************
    \\*/
    \\
    \\/* Memories definition */
    \\MEMORY
    \\{
    \\
;

const ld_part2 =
    \\}
    \\
    \\/* Entry Point */
    \\ENTRY(resetHandler)
    \\
    \\/* Enforce emmition of the vector table. */
    \\EXTERN (vector_table)
    \\
    \\/* This provide weak linking to empty handlers, which can be overridden */
    \\PROVIDE(_stack = ORIGIN(RAM) + LENGTH(RAM));
    \\PROVIDE(nmiHandler = nullHandler);
    \\PROVIDE(hardFaultHandler = blockingHandler);
    \\PROVIDE(memoryManagementFaultHandler = blockingHandler);
    \\PROVIDE(busFaultHandler = blockingHandler);
    \\PROVIDE(usageFaultHandler = blockingHandler);
    \\PROVIDE(svCallHandler = nullHandler);
    \\PROVIDE(debugMonitorHandler = nullHandler);
    \\PROVIDE(pendSVHandler = nullHandler);
    \\PROVIDE(sysTickHandler = nullHandler);
    \\
    \\/* Sections */
    \\SECTIONS
    \\{
    \\  .text : {
    \\    *(.vectors)  /* Vector table */
    \\    *(.text*)  /* Program code */
    \\    . = ALIGN(4);
    \\  } >FLASH
    \\
    \\  .rodata : {
    \\    *(.rodata*)  /* Read-only data */
    \\    . = ALIGN(4);
    \\  } >FLASH
    \\
    \\  /* C++ Static constructors/destructors, also used for __attribute__
    \\   * ((constructor)) and the likes */
    \\  .preinit_array : {
    \\    . = ALIGN(4);
    \\    KEEP (*(.preinit_array))
    \\  } >FLASH
    \\
    \\  .init_array : {
    \\    . = ALIGN(4);
    \\    KEEP (*(SORT(.init_array.*)))
    \\    KEEP (*(.init_array))
    \\  } >FLASH
    \\
    \\  .fini_array : {
    \\    . = ALIGN(4);
    \\    KEEP (*(.fini_array))
    \\    KEEP (*(SORT(.fini_array.*)))
    \\  } >FLASH
    \\
    \\  /*
    \\   * Another section used by C++ stuff, appears when using newlib with
    \\   * 64bit (long long) printf support
    \\   */
    \\  .ARM.extab : {
    \\    *(.ARM.extab*)
    \\  } >FLASH
    \\
    \\  .ARM.exidx : {
    \\    *(.ARM.exidx*)
    \\  } >FLASH
    \\
    \\  /* RAM, but not cleared on reset, eg boot/app comms */
    \\  .noinit (NOLOAD) : {
    \\    *(.noinit*)
    \\  } >RAM
    \\  . = ALIGN(4);
    \\
    \\  .data : {
    \\    __data_start__ = .;
    \\    *(.data*)  /* Read-write initialized data */
    \\    *(.ramtext*)    /* "text" functions to run in RAM */
    \\    . = ALIGN(4);
    \\    __data_end__ = .;
    \\  } >RAM AT >FLASH
    \\  __data_loadaddr__ = LOADADDR(.data);
    \\
    \\  .bss : {
    \\    __bss_start__ = .;
    \\    *(.bss*)  /* Read-write zero initialized data */
    \\    *(COMMON)
    \\    . = ALIGN(4);
    \\    __bss_end__ = .;
    \\  } >RAM
    \\
    \\  /*
    \\   * The .eh_frame section appears to be used for C++ exception handling.
    \\   * You may need to fix this if you're using C++.
    \\   */
    \\  /DISCARD/ : { *(.eh_frame) }
    \\}
    \\
;

pub fn generate(allocator: Allocator, dir: Dir, memory: MemorySection, reader: Reader) anyerror!void {
    var v = dir.createFile("vector.zig", .{}) catch |err| return err;
    defer v.close();
    var s = dir.createFile("startup.zig", .{}) catch |err| return err;
    defer s.close();
    var m = dir.createFile("main.zig", .{}) catch |err| return err;
    defer m.close();
    var l = dir.createFile("l.ld", .{}) catch |err| return err;
    defer l.close();
    var r = dir.createFile("registers.zig", .{}) catch |err| return err;
    defer r.close();

    const lw = l.writer();
    const rw = r.writer();

    _ = v.write(vector_table) catch |err| return err;
    _ = s.write(startup) catch |err| return err;
    _ = m.write(main) catch |err| return err;
    generator.generate(allocator, &reader, &rw) catch |err| return err;
    _ = l.write(ld_part1) catch |err| return err;
    lw.print("  FLASH    (rx)    : ORIGIN = {s},   LENGTH = {s}\n", .{ memory.flash.origin, memory.flash.length }) catch |err| return err;
    lw.print("  RAM    (rx)    : ORIGIN = {s},   LENGTH = {s}\n", .{ memory.ram.origin, memory.ram.length }) catch |err| return err;
    _ = l.write(ld_part2) catch |err| return err;
}
